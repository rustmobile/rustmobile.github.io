# Uniffi Setup

We are going to use `uniffi` to generate Swift and Kotlin bindings. Then,
we will add a logger initializer and see the generating bindings.

These are only language bindings. Building and linking to the native library
will come later.

With uniffi, we can write interface definitions inside the `.udl` file
(uniffi definition language), and uniffi can grab the `.udl` file and generate
language bindings depending on the interface definitions we provide.

## Lib Setup

Let us start by adding library configuration inside `glue/mobile/Cargo.toml`
add the following:

```toml [hl,6-8]
[package]
name = "mobile"
version = "0.1.0"
edition = "2021"

[lib]
name = "exa"
crate-type = ["staticlib", "cdylib"]

[dependencies]
```

The `name` will be our generated library name. It has the form of `lib<name>`.
We made the crate type `staticlib` to generate `lib<name>.a` files and use them
for iOS targets, and `cdylib` are for generating `lib<name>.so` and use it for
our Android targets.

## Adding Uniffi

We should add uniffi as a build, bin, and library dependency,
but each has a different feature.

> TBH, I could not figure out how to have three different dependencies in
> `Cargo.toml`, so I combined the features needed for bin and lib dependencies u
> nder `[dependencies]`

Inside `glue/mobile/Cargo.toml`

```toml [hl,10-14]
[package]
name = "mobile"
version = "0.1.0"
edition = "2021"

[lib]
name = "exa"
crate-type = ["staticlib", "cdylib"]

[dependencies]
uniffi = { version = "0.23.0", features = ["cli"] }

[build-dependencies]
uniffi = { version = "0.23.0", features = ["build"] }
```

Let us start with generating the bindings function. Create in our mobile crate
`main.rs` and add the generating function:

```rust
fn main() {
    uniffi::uniffi_bindgen_main();
}
```

Now to our library, remove all the content of `lib.rs` in our
mobile crate and include the scaffold rust file generated by uniffi
(not generated yet. We are going to do so in `build.rs`)

```rust
uniffi::include_scaffolding!("exa");
```

And finally, create a `build.rs` file inside the mobile crate but outside the src.

```rust
fn main() {
    uniffi::generate_scaffolding("./src/exa.udl").unwrap();
}
```

In `build.rs`, we want to generate a scaffolding from a file
called `exa.udl` inside `src`.

You might see errors if your editor builds on save since the file `exa.udl`
still needs to be created. Let us create it in the mobile crate inside the `src`

```cpp
namespace exa { };
```

Now the errors should be gone. And we can generate bindings, but wait,
let us add a simple functionality and then generate the bindings
to see if all is good.

## Adding Logger

On Android, we log using `logcat`. On iOS, we log to `stdout`, so for Android,
we can use `android_logger`, and for iOS, we can use `simple_logger`

For better optimizations, we can have conditional dependencies,
add `android_logger` if the target operating system is Android, else use `simple_logger`

```toml [hl,11,12,15-19]
[package]
name = "mobile"
version = "0.1.0"
edition = "2021"

[lib]
name = "exa"
crate-type = ["staticlib", "cdylib"]

[dependencies]
log = "0.4.17"
log-panics = "2.1.0"
uniffi = { version = "0.23.0", features = ["cli"] }

[target.'cfg(target_os="android")'.dependencies]
android_logger = "0.13.1"

[target.'cfg(not(target_os="android"))'.dependencies]
simple_logger = "4.0.0"

[build-dependencies]
uniffi = { version = "0.23.0", features = ["build"] }
```

Now create `logger.rs` in `src` in our mobile crate.

We want to use `android_logger to initialize the logger` if the target OS is
Android. We can create a configuration block and check the `target_os`

```rust
use log::{info, LevelFilter};

pub fn init_logger() {
    #[cfg(target_os = "android")]
    {
        android_logger::init_once(
            android_logger::Config::default()
                .with_max_level(LevelFilter::Trace)
                .with_tag("Exa"),
        );
        info!("Logger initialized");
    }

    #[cfg(not(target_os = "android"))]
    {
        let logger = simple_logger::SimpleLogger::new()
            .with_level(LevelFilter::Trace)
            .with_colors(false)
            .init();

        match logger {
            Ok(()) => info!("Logger initialized"),
            Err(_) => { },
        };
    }

    log_panics::init();
}
```

Now add that as a module inside `lib.rs`

```rust [hl,1-3]
mod logger;

use crate::logger::*;

uniffi::include_scaffolding!("exa");
```

And finally, add the function signature to `exa.udl` so we can generate the bindings!

```cpp [hl,2]
namespace exa {
    void init_logger();
};
```

## Generating the bindings

We want to execute the `main.rs` function inside the mobile
crate to generate the bindings.

To do so, open the terminal and change the directory to the root project
(`exa-library`). From there, we run `cargo run` and pick the binary we want to run.

```bash
cargo run --bin mobile -- --help
```

You should be able to see the help message:

```text
Scaffolding and bindings generator for Rust

USAGE:
    mobile <SUBCOMMAND>

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    generate       Generate foreign language bindings
    help           Print this message or the help of the given subcommand(s)
    print-json     Print the JSON representation of the interface from a dynamic library
    scaffolding    Generate Rust scaffolding code
```

Let us generate rust scaffolding and check the output:

```bash
cargo run --bin mobile -- \
	scaffolding ./glue/mobile/src/exa.udl \
	-o ./target/bindings
```

This will generate `exa.uniffi.rs` inside `target/bindings`.

If you open the file and scroll down, you should see our `init_logger`,
but not precisely as we anticipate it.

> It has the form of `<namespace>-<hash>-<function name>` to avoid collisions.

For me, it was generated like this:

```rust
#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value)]
pub extern "C" fn r#exa_5e46_init_logger(
    call_status: &mut uniffi::RustCallStatus
) {
    uniffi::deps::log::debug!("exa_5e46_init_logger");

    uniffi::call_with_output(call_status, || {
        #[allow(clippy::redundant_closure)]
        r#init_logger()
    })
}
```

Let us generate Kotlin bindings and check the output

```bash
cargo run --bin mobile -- \
	generate ./glue/mobile/src/exa.udl \
	-l kotlin \
	-o ./target/bindings
```

The output should be `target/bindings/uniffi/exa/exa.kt`

Again, scroll down and check the `initLogger` function:

```kotlin
fun `initLogger`() =
    rustCall() { _status ->
        _UniFFILib.INSTANCE.exa_5e46_init_logger(_status)
    }
```

> Notice the function name is escaped using the backticks `` `initLogger` ``.
> So our functions doesn't collide with a language keyword.
> For example: we can have a function named `switch` to
> switch between two things. It's fine for Kotlin and Rust
> but Swift will start throwing errors. So we should escape the name.

This calls another function called `exa_5e46_init_logger` inside this file.

As you noticed, both the rust scaffolding and the Kotlin bindings
have the hash `5e46` in my case.

We can also do the same for Swift:

```bash
cargo run --bin mobile -- \
	generate ./glue/mobile/src/exa.udl \
	-l swift \
	-o ./target/bindings
```

The output is pretty similar to the Kotlin one:

```swift
public func `initLogger`()  {
    try! rustCall() {
        exa_5e46_init_logger($0)
    }
}
```

> Don't expect the output to be formatted like this,
> I manually formatted that for the sake of have a
> good looking code inside the book ðŸ˜…
